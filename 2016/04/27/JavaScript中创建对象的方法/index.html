<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="ShaunZheng">
    

    <!--Author-->
    
        <meta name="author" content="郑爽">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="JavaScript中创建对象的方法"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="ShaunZheng" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="ShaunZheng"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>JavaScript中创建对象的方法 - ShaunZheng</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Shaun
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="http://scooling.github.io/about/">
                    About
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2016/04/27/JavaScript中创建对象的方法/">
                JavaScript中创建对象的方法
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-04-27</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <p><strong>1.最简单的方法就是创建一个Object实例，然后为其添加属性和方法：（缺点：使用同一个接口创建很多对象，会产生大量的代码）</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"cooling"</span>;</span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line">person.job = <span class="string">"Web Engineer"</span>;</span><br><span class="line">person.sayName() = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;<span class="comment">//注意这里有分号</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.对象字面量语法：（缺点：使用同一个接口创建很多对象，会产生大量的代码）</strong></p>
<blockquote>
<p>注意和上面的区别：用“，”号分隔，用的是“:”号赋值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	name : <span class="string">"cooling"</span>,<span class="comment">//注意这里是逗号</span></span><br><span class="line">	age : <span class="number">20</span>,</span><br><span class="line">	job : <span class="string">"Web Engineer"</span>,</span><br><span class="line">	sayName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.工厂模式：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.job = job;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'cooling1'</span>,<span class="number">20</span>,<span class="string">'Web Engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">'cooling2'</span>,<span class="number">23</span>,<span class="string">'Web Engineer'</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>4.构造函数模式：</strong></p>
<blockquote>
<p>注意：这里可是构造函数法的详细用法！像Object和Array这样的原生构造函数，在运行时，会自动出现在执行的环境中。此外也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。按照惯例，构造函数的首字母都应该大写，非构造函数用小写。</p>
</blockquote>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'cooling1'</span>,<span class="number">20</span>,<span class="string">'Web Engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'cooling2'</span>,<span class="number">23</span>,<span class="string">'Web Engineer'</span>);</span><br></pre></td></tr></table></figure>
<p><em>上述person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person。</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.constructor == Person);<span class="comment">//true</span></span><br><span class="line">alert(person2.constructor == Person);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><em>对象的constructor属性最初是用来标识对象的类型的。但是，提到检测对象类型，还是使用instanceof操作符更靠谱些。</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>①构造函数解析：</p>
<blockquote>
<p>构造函数与普通函数的唯一区别就在于调用他们的方式不同。任何函数，只要是通过new操作符来调用，那么他就是构造函数；而任何函数，如果不通过new来调用，它就和普通函数没太大区别，最多也就是首字母大写了而已。一旦函数被作为构造函数执行，它内部的this属性将引用函数本身。</p>
</blockquote>
<p>当成构造函数使用时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'cooling1'</span>,<span class="number">20</span>,<span class="string">'Web Engineer'</span>);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure></p>
<p>当成普通函数使用时：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="string">'cooling1'</span>,<span class="number">20</span>,<span class="string">'Web Engineer'</span>);</span><br><span class="line">windown.sayName();</span><br></pre></td></tr></table></figure></p>
<p>②构造函数的缺点：</p>
<p>不同实例上（person1和person2就分别为一个实例）的同名函数是不相等的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.sayName == person2.sayName);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其允许你给对象配置同样的属性，但是构造函数并没有消除代码的冗余。在上面的例子中，每一个对象（person1和person2就分别为一个对象）都有自己的sayName()方法。这就意外着，如果你有100个实例对象，你就有100个sayName()函数做相同的事情，只是数据不同。</p>
</blockquote>
<p>解决方案：(把函数的定义转移到构造函数的外部)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'cooling1'</span>,<span class="number">20</span>,<span class="string">'Web Engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'cooling2'</span>,<span class="number">23</span>,<span class="string">'Web Engineer'</span>);</span><br></pre></td></tr></table></figure></p>
<p><em>这里依旧存在问题：<br>a.在全局作用域中定义的函数，实际上只能够被某个对象调用。<br>b.如果存在很多 的方法，那么就需要定义很多个全局函数，这个时候自定义的引用类型就毫无封装性了。</em></p>
<p><strong>5.原型模式：</strong></p>
<p>①代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"cooling"</span>;</span><br><span class="line">Person.prototype.age= <span class="number">20</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Web Engineer"</span>;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();<span class="comment">//cooling</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();<span class="comment">//cooling</span></span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://ww2.sinaimg.cn/mw690/005CMnY7gw1f3a65dcv6tj30ij0bmabv.jpg" style="border-radius: 5px; box-shadow: 0 0 5px #C5C2C2"></p>
<p>②解释：</p>
<p>a.我们创建的任何一个函数，都有一个prototype属性（也就是原型属性）。该属性是一个指针，指向一个对象（也就是原型对象），这个对象包含了很多公用的属性和方法。</p>
<p>b.在默认情况下，所有原型对象都会自动获得一个constructor属性（也就是构造函数属性），这个构造函数属性包含一个指针，这个指针又指向原函数。这里是Person.prototype.constructor指向Person。</p>
<p>c.调用构造函数创建对象（新实例）的时候，该实例内部将包含一个指针（内部属性，跟原型属性类似），该指针指向原型对象。这个指针为[[Prototype]],在脚本中，没有标准的的方式访问该指针。但是，在Firefox Safari Chrome中，每一个对象都支持一个__proto__属性。</p>
<p><em>注意：虽然在任何实现中都无法访问到[[Prototype]]，但是可以通过isPrototypeOf()方法来确定原型对象和实例化的对象之间是否有这种关系（如果[[Prototype]]指向调用isPrototypeOf()方法的对象Person.prototype，那么返回true），如下</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(Person.prototype.isPrototypeOf(person1));<span class="comment">//true</span></span><br><span class="line">alert(Person.prototype.isPrototypeOf(person2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>！<strong>严重注意：</strong><br>ECMAScript 5中新增了个方法：Object.getPrototypeOf(),在所有支持的实现中，这个方法可以返回[[Prototype]]的值。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype);<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.getPrototypeOf(person1).name);<span class="comment">//cooling1</span></span><br></pre></td></tr></table></figure></p>
<p>③调用属性和方法的顺序：</p>
<p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"cooling"</span>;</span><br><span class="line">Person.prototype.age= <span class="number">20</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Web Engineer"</span>;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">"zs1"</span></span><br><span class="line">person1.sayName();<span class="comment">//zs1</span></span><br><span class="line">person2.sayName();<span class="comment">//cooling</span></span><br></pre></td></tr></table></figure></p>
<p><em>通过上面的代码，可以了解，在调用属性或者方法的时候，优先使用实例化的对象上现有的属性和方法。如果实例化的对象上没有，再向函数的原型对象上去找。注意：实例化的对象，可以访问原型对象的属性和方法，但是不能修改它。</em></p>
<p>不过，可以通过delete将其删除：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> person1.name;</span><br><span class="line">person1.sayName();<span class="comment">//cooling</span></span><br></pre></td></tr></table></figure></p>
<p>④检测：<br>使用hasOwnProperty()方法，可以检测一个属性是存在于实例对象中的，还是存在于原型对象中的。只在给定属性存在于实例对象中，才返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"cooling"</span>;</span><br><span class="line">Person.prototype.age= <span class="number">20</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Web Engineer"</span>;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">"zs1"</span></span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>);<span class="comment">//true</span></span><br><span class="line">alert(person2.hasOwnProperty(<span class="string">"name"</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>⑤原型与in操作符：</p>
<p>a.通过对象访问给定的属性时，使用in操作符，始终返回true。也就是说，无论属性是直接在对象上访问到的，还是在原型对象上访问到的，使用in操作符都会返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"cooling"</span>;</span><br><span class="line">Person.prototype.age= <span class="number">20</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Web Engineer"</span>;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.name = <span class="string">"zs2"</span>;</span><br><span class="line"></span><br><span class="line">alert(person1.hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//false</span></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person1);<span class="comment">//true</span></span><br><span class="line">alert(<span class="string">"name"</span> <span class="keyword">in</span> person2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>b.通过结合hasOwnProperty()方法，可以判断属性或者方法是位于实例对象上，还是位于原型对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object,name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>c.for…in:返回的是所有能够通过对象访问的，可以枚举的属性，其中既包括实例对象中的，也包括原型对象中的。对于原型对象中，不可枚举的，进行了屏蔽，也就是说尽管你不可枚举，但是在使用我for…in的时候，我依然是把你当成可枚举的。（在IE8及其以下，没有起到屏蔽作用，也就是说，不可枚举就是不可枚举）。<br>注：不可枚举指的是[[Enumerable]]标记为false<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">	toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"My Object"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o)&#123;</span><br><span class="line">	<span class="keyword">if</span> (prop == <span class="string">"toString"</span>) &#123;</span><br><span class="line">		alert(<span class="string">"Found toString"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>此处看不到弹出框，原因是原型的toString()方法的[[Enumerable]]标记为false。具体细节比较繁琐，详见《高级程序设计》153页。</p>
</blockquote>
<p>取得对象上所有可以枚举的实例属性，还可以使用Object.keys()方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"cooling"</span>;</span><br><span class="line">Person.prototype.age= <span class="number">20</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Web Engineer"</span>;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</span><br><span class="line">alert(keys);<span class="comment">//name age job sayName</span></span><br></pre></td></tr></table></figure>
<p><em>如果你想得到所有的实例属性，不管是否可以枚举。可以使用Object.getOwnPropertyNames()方法：</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getPropertyNames(Person.prototype);</span><br><span class="line">alert(keys);<span class="comment">//constructor name age job sayName</span></span><br></pre></td></tr></table></figure></p>
<p>⑥更简单的原型语法：<br>为了方便，可以这么使用原型模式创建对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name : <span class="string">"cooling"</span>,</span><br><span class="line">    job : <span class="string">"web engineer"</span>,</span><br><span class="line">    age : <span class="number">20</span>,</span><br><span class="line">    sayName : functon()&#123;</span><br><span class="line">    	alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是，这个时候相当于是用对象字面量形式创建了一个新的对象,因此，创建的实例对象的指向的原型对象的constructor属性就不再回指原函数Person。如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">alert(friend.constructor == Person);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>不过，可以这么干：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	<span class="keyword">constructor</span> ： Person,//手动让它指向Person！</span><br><span class="line">	name : "cooling",</span><br><span class="line">    job : "web engineer",</span><br><span class="line">    age : 20,</span><br><span class="line">    sayName : functon()&#123;</span><br><span class="line">    	alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可是，这样的话，会导致constructor的[[Enumerable]]特性被设置成true，原生的应该是false（不可枚举的）。所以，还可以这么干：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	name : <span class="string">"cooling"</span>,</span><br><span class="line">    job : <span class="string">"web engineer"</span>,</span><br><span class="line">    age : <span class="number">20</span>,</span><br><span class="line">    sayName : functon()&#123;</span><br><span class="line">    	alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重设构造函数</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype,<span class="string">"constructor"</span>,&#123;</span><br><span class="line">	enumerable : <span class="literal">false</span>;</span><br><span class="line">    value : Person;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>⑦原型的动态性：</p>
<p>所谓原型的动态性，就是指随时可以为函数的原型对象添加属性和方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"Hi!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi();<span class="comment">//Hi</span></span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，随时为函数的原型对象添加属性和方法没有问题。但是如果用如同对象字面量方式创建新的对象，从而添加属性和方法是严重有问题的。因为，这个时候，新建的对象的原型和之前的构造函数的原型不是一个！（这个时候需要注意创建对象的顺序了，如果是先new了，接着再对象字面量创建的话，那么原型对象就重写了。）如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	<span class="keyword">constructor</span> : Person,</span><br><span class="line">	name : "cooling",</span><br><span class="line">	age : 22,</span><br><span class="line">	sayName : function()&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> girlFriend = <span class="keyword">new</span> Person();</span><br><span class="line">girlFriend.sayName();<span class="comment">//cooling</span></span><br><span class="line">friend.sayName();<span class="comment">//error（浏览器无任何响应）</span></span><br></pre></td></tr></table></figure></p>
<p>⑧原生对象原型&amp;&amp;原型对象的问题：<br>a.原生对象原型可以像自定义对象原型一样，可以随时添加属性和方法。<br>b.问题：对于包含引用类型值的属性，存在较大问题。<br><strong>6.组合使用构造函数模式和原型模式（！最常用最推荐的方式）</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age,name,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.friend = [<span class="string">'cooling1'</span>,<span class="string">'cooling2'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	<span class="keyword">constructor</span> :Person,</span><br><span class="line">	sayName : function()&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="number">20</span>,<span class="string">'cooling'</span>,<span class="string">'Web Engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="number">22</span>,<span class="string">'cooling'</span>,<span class="string">'Web Engineer'</span>);</span><br><span class="line"></span><br><span class="line">person1.friend.push(<span class="string">"cooling3"</span>);</span><br><span class="line">alert(person1.friend);<span class="comment">//1,2,3</span></span><br><span class="line">alert(person2.friend);<span class="comment">//1,2</span></span><br><span class="line">alert(person1.friend == person2.friend);<span class="comment">//false</span></span><br><span class="line">alert(person1.sayName == person2.sayName);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>7.动态原型模式</strong><br>所谓动态原型模式，就是通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。它是在构造函数模式的基础上，改进了构造函数模式会多次创建方法函数，产生大量内存的问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="comment">//这里比较关键</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">		Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="keyword">this</span>.name);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>！注意：这里对原型做的修改，可以立即在<strong>所有实例</strong>中得到反应！</p>
<p><strong>8.寄生构造函数模式</strong><br>和工厂模式的区别就在于使用了<strong>new</strong>！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.job = job;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> people = <span class="keyword">new</span> Person(<span class="string">'123'</span>,<span class="number">23</span>,<span class="string">'213'</span>);</span><br><span class="line">people.sayName();<span class="comment">//123</span></span><br></pre></td></tr></table></figure></p>
<p><strong>9.稳妥构造函数模式</strong><br>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。其不使用new操作符调用构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.job = job;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(name);<span class="comment">//注意这里</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> people = Person(<span class="string">'123'</span>,<span class="number">23</span>,<span class="string">'213'</span>);</span><br><span class="line">people.sayName();<span class="comment">//123</span></span><br></pre></td></tr></table></figure></p>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/JavaScript/">#JavaScript</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    博客迁移自 <a href="https://scooling.github.io">郑爽</a> | 本人的知乎首页<a href="https://www.zhihu.com/people/zheng-shuang-36-4">知乎</a> | 交流学习WeChat: DINGJING. Never let yourself be a substitute for anyone!
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/01/20/ML实战2-1的Python知识点总结/">ML实战2-1的Python知识点总结</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2016/06/01/Git使用命令/">Git常用命令</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2016/05/27/JavaScript中的字符串拼接/">JavaScript中的字符串拼接</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2016/05/16/关于NodeJS中类似函数参数arguments的问题/">关于NodeJS中类似函数参数arguments的</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/ShaunZheng">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:i@cooling.red">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    由Hexo强力驱动 | @shaun. All right reserved | Theme <a href="http://www.codeblocq.com/assets/projects/hexo-theme-alpha-dust/">AlphaDust</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>